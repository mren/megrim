// Generated by CoffeeScript 1.7.1
var Mesa, async, fs, _;

fs = require('fs');

Mesa = require('mesa');

_ = require('underscore');

async = require('async');

module.exports = function(path, connection, cb) {
  var addSqlToMigration, addVersionToSchemaInfo, createSchemaInfoTableIfNotExists, executeMigration, executeMigrations, getAllAlreadyExecutedMigrations, getAvailableMigrations, getNewMigrations, getSchemaVersion, isValidSchemaFile, mesa, parseSchemaFileName, results;
  if (cb == null) {
    cb = function() {};
  }
  mesa = Mesa.connection(connection).table('schema_info').attributes(['version']).returning('version');
  results = [];
  getSchemaVersion = function(cb) {
    return mesa.find(cb);
  };
  createSchemaInfoTableIfNotExists = function(cb) {
    return connection.query("CREATE TABLE IF NOT EXISTS schema_info (version bigint NOT NULL UNIQUE);", cb);
  };
  addVersionToSchemaInfo = function(version, cb) {
    return mesa.insert({
      version: version
    }, cb);
  };
  parseSchemaFileName = function(filename) {
    var date;
    date = parseInt(filename.split('-').shift(), 10);
    return {
      filename: filename,
      extension: filename.split('.').pop(),
      version: date,
      description: filename.substr(date.toString().length + 1).split('.').shift()
    };
  };
  isValidSchemaFile = function(schemaFile) {
    var extension, version;
    version = schemaFile.version, extension = schemaFile.extension;
    return schemaFile.extension === 'sql' && !isNaN(version) && ("" + version).length === 14;
  };
  getAvailableMigrations = function() {
    var availableSchemas, filenames, validSchemas;
    filenames = fs.readdirSync(path);
    availableSchemas = filenames.map(function(filename) {
      return parseSchemaFileName(filename);
    });
    validSchemas = availableSchemas.filter(isValidSchemaFile);
    return _.sortBy(validSchemas, function(schema) {
      return schema.version;
    });
  };
  getAllAlreadyExecutedMigrations = function(cb) {
    return getSchemaVersion(function(err, schemas) {
      if (err != null) {
        return cb(err);
      }
      return cb(null, _.pluck(schemas, 'version'));
    });
  };
  getNewMigrations = function(availableSchemas, executedVersions) {
    return availableSchemas.filter(function(schemaFile) {
      return !_.include(executedVersions, "" + schemaFile.version);
    });
  };
  addSqlToMigration = function(migration) {
    migration.sql = fs.readFileSync("" + path + "/" + migration.filename, 'utf8');
    return migration;
  };
  executeMigration = function(migration, cb) {
    return connection.query(migration.sql, function(err, result) {
      if (err != null) {
        return cb(err);
      }
      return addVersionToSchemaInfo(migration.version, function(err) {
        if (err != null) {
          return cb(err);
        }
        results.push("added " + migration.description + " to database");
        return cb(null);
      });
    });
  };
  executeMigrations = function(cb) {
    return createSchemaInfoTableIfNotExists(function(err) {
      var availableSchemas;
      if (err != null) {
        return cb(err);
      }
      availableSchemas = getAvailableMigrations();
      return getAllAlreadyExecutedMigrations(function(err, executedVersions) {
        var newMigrations, withSql;
        if (err != null) {
          return cb(err);
        }
        newMigrations = getNewMigrations(availableSchemas, executedVersions);
        withSql = newMigrations.map(addSqlToMigration);
        return async.forEach(withSql, executeMigration, cb);
      });
    });
  };
  return executeMigrations(function(err) {
    return cb(err, results);
  });
};
